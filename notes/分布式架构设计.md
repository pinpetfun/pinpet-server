# Spin Server 分布式架构设计

## 概述

本文档描述如何将 Spin Server 部署为分布式系统，使用 Cloudflare 作为协调层来管理多台服务器实例，特别是处理 mint_account 相关数据的分片和负载均衡。

## 当前架构分析

### 数据特征
- **核心数据维度**: mint_account (代币铸币地址)
- **存储引擎**: RocksDB (本地键值存储)
- **数据前缀**:
  - `mt:` - Token markers
  - `tr:` - Transaction events  
  - `or:` - Order data
  - `us:` - User events
  - `in:` - Token info

### 数据分片天然性
- 每个 mint_account 的数据相对独立
- 交易事件、订单数据都按 mint_account 组织
- WebSocket 订阅也是基于 mint_account 进行的

## 核心挑战：动态数据分布问题

### 问题分析
每台服务器启动时间不同，监听到的区块链事件也不同，导致：

1. **数据分布不均**: 早启动的服务器可能有更多历史 mint_account
2. **数据分散**: 同一个 mint_account 的不同时间段数据可能在不同服务器上
3. **动态性**: 新的 mint_account 会随时出现，无法预先分配
4. **查询困难**: 客户端不知道某个 mint_account 的数据在哪台服务器上

### 解决方案：分布式数据索引 + 动态路由

#### 方案一: 全局数据索引服务

```rust
// src/services/mint_registry.rs
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MintServerMapping {
    pub mint_account: String,
    pub servers: Vec<ServerInfo>,        // 哪些服务器有这个 mint 的数据
    pub data_ranges: Vec<DataRange>,     // 每个服务器的数据时间范围
    pub last_updated: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerInfo {
    pub server_id: String,
    pub endpoint: String,
    pub health_status: String,
    pub data_from: i64,                  // 该服务器数据起始时间
    pub data_to: i64,                    // 该服务器数据结束时间
    pub event_count: usize,              // 该 mint 在此服务器的事件数量
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataRange {
    pub server_id: String,
    pub start_slot: u64,
    pub end_slot: u64,
    pub event_types: Vec<String>,        // 该服务器有哪些事件类型
}

/// 全局 mint 注册表服务
pub struct MintRegistry {
    // 使用 Cloudflare D1 或者 KV 存储
    mappings: HashMap<String, MintServerMapping>,
    http_client: reqwest::Client,
}

impl MintRegistry {
    /// 注册新的 mint_account 到服务器映射
    pub async fn register_mint(&mut self, 
        mint_account: String, 
        server_info: ServerInfo,
        data_range: DataRange
    ) -> Result<()> {
        let mapping = self.mappings.entry(mint_account.clone())
            .or_insert_with(|| MintServerMapping {
                mint_account: mint_account.clone(),
                servers: Vec::new(),
                data_ranges: Vec::new(),
                last_updated: chrono::Utc::now().timestamp(),
            });
        
        // 更新或添加服务器信息
        if let Some(existing) = mapping.servers.iter_mut()
            .find(|s| s.server_id == server_info.server_id) {
            *existing = server_info;
        } else {
            mapping.servers.push(server_info);
        }
        
        // 更新数据范围
        if let Some(existing) = mapping.data_ranges.iter_mut()
            .find(|r| r.server_id == data_range.server_id) {
            *existing = data_range;
        } else {
            mapping.data_ranges.push(data_range);
        }
        
        mapping.last_updated = chrono::Utc::now().timestamp();
        
        // 持久化到 Cloudflare KV
        self.persist_mapping(&mint_account, mapping).await?;
        
        Ok(())
    }
    
    /// 查找 mint_account 对应的服务器
    pub async fn find_servers_for_mint(&self, mint_account: &str) -> Option<Vec<ServerInfo>> {
        if let Some(mapping) = self.mappings.get(mint_account) {
            // 过滤健康的服务器
            let healthy_servers: Vec<ServerInfo> = mapping.servers.iter()
                .filter(|s| s.health_status == "healthy")
                .cloned()
                .collect();
            
            if !healthy_servers.is_empty() {
                return Some(healthy_servers);
            }
        }
        
        // 从持久化存储查询
        self.load_mapping_from_storage(mint_account).await
    }
    
    /// 智能选择最佳服务器
    pub fn select_best_server(&self, servers: &[ServerInfo], query_type: &str) -> Option<&ServerInfo> {
        match query_type {
            "latest" => {
                // 选择数据最新的服务器
                servers.iter().max_by_key(|s| s.data_to)
            },
            "complete" => {
                // 选择数据最完整的服务器
                servers.iter().max_by_key(|s| s.event_count)
            },
            "range" => {
                // 选择数据范围最广的服务器
                servers.iter().max_by_key(|s| s.data_to - s.data_from)
            },
            _ => servers.first()
        }
    }
}
```

#### 方案二: Cloudflare Workers 实现动态路由

```javascript
// cloudflare-worker-advanced.js
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const mintAccount = extractMintAccount(request, url);
    
    if (mintAccount) {
      return await handleMintRequest(request, mintAccount, env);
    }
    
    return await defaultLoadBalance(request, env);
  }
};

async function handleMintRequest(request, mintAccount, env) {
  try {
    // 1. 查询 mint_account 的服务器映射
    const servers = await findServersForMint(mintAccount, env);
    
    if (servers.length === 0) {
      // 没有服务器有这个 mint 的数据，广播查询
      return await broadcastMintQuery(request, mintAccount, env);
    }
    
    // 2. 选择最佳服务器
    const targetServer = selectBestServer(servers, request);
    
    // 3. 转发请求
    const response = await forwardToServer(request, targetServer);
    
    // 4. 如果失败，尝试其他服务器
    if (!response.ok && servers.length > 1) {
      return await tryOtherServers(request, servers, targetServer);
    }
    
    return response;
    
  } catch (error) {
    console.error(`Error handling mint request: ${error}`);
    return new Response('Service Unavailable', { status: 503 });
  }
}

async function findServersForMint(mintAccount, env) {
  // 从 Cloudflare KV 查询
  const mappingKey = `mint:${mintAccount}`;
  const mappingStr = await env.MINT_REGISTRY.get(mappingKey);
  
  if (!mappingStr) {
    return [];
  }
  
  const mapping = JSON.parse(mappingStr);
  
  // 过滤健康的服务器
  const healthyServers = [];
  for (const server of mapping.servers) {
    if (await isServerHealthy(server, env)) {
      healthyServers.push(server);
    }
  }
  
  return healthyServers;
}

async function broadcastMintQuery(request, mintAccount, env) {
  console.log(`Broadcasting query for mint: ${mintAccount}`);
  
  // 并行查询所有服务器
  const promises = env.SERVERS.map(server => 
    queryServerForMint(request, server, mintAccount)
  );
  
  const results = await Promise.allSettled(promises);
  
  // 找到第一个成功的响应
  for (const result of results) {
    if (result.status === 'fulfilled' && result.value.ok) {
      // 更新注册表
      await updateMintRegistry(mintAccount, result.value.server, env);
      return result.value.response;
    }
  }
  
  return new Response(JSON.stringify({
    error: 'mint_account not found',
    mint_account: mintAccount,
    message: 'No server has data for this mint account'
  }), { 
    status: 404,
    headers: { 'Content-Type': 'application/json' }
  });
}

async function queryServerForMint(request, server, mintAccount) {
  try {
    const serverUrl = new URL(request.url);
    serverUrl.hostname = server.hostname;
    serverUrl.port = server.port || '';
    
    const response = await fetch(serverUrl.toString(), {
      method: request.method,
      headers: request.headers,
      body: request.body
    });
    
    return {
      ok: response.ok,
      server: server,
      response: response
    };
  } catch (error) {
    return {
      ok: false,
      server: server,
      error: error.message
    };
  }
}

async function updateMintRegistry(mintAccount, server, env) {
  const mappingKey = `mint:${mintAccount}`;
  const now = Date.now();
  
  let mapping;
  const existing = await env.MINT_REGISTRY.get(mappingKey);
  
  if (existing) {
    mapping = JSON.parse(existing);
  } else {
    mapping = {
      mint_account: mintAccount,
      servers: [],
      last_updated: now
    };
  }
  
  // 添加或更新服务器信息
  const serverIndex = mapping.servers.findIndex(s => s.id === server.id);
  if (serverIndex >= 0) {
    mapping.servers[serverIndex].last_seen = now;
  } else {
    mapping.servers.push({
      id: server.id,
      hostname: server.hostname,
      port: server.port,
      first_seen: now,
      last_seen: now
    });
  }
  
  mapping.last_updated = now;
  
  // 保存到 KV，设置 24 小时过期
  await env.MINT_REGISTRY.put(mappingKey, JSON.stringify(mapping), {
    expirationTtl: 86400
  });
}
```

#### 方案三: 服务器端主动注册

```rust
// src/services/registry_client.rs
pub struct RegistryClient {
    registry_endpoint: String,
    server_id: String,
    http_client: reqwest::Client,
}

impl RegistryClient {
    /// 启动时注册本服务器的所有 mint_account
    pub async fn register_all_mints(&self, event_storage: &EventStorage) -> Result<()> {
        let mints = event_storage.get_all_mints().await?;
        
        for mint in mints {
            let stats = event_storage.get_mint_stats(&mint).await?;
            
            let registration = MintRegistration {
                mint_account: mint.clone(),
                server_id: self.server_id.clone(),
                data_from: stats.first_event_time,
                data_to: stats.last_event_time,
                event_count: stats.total_events,
                event_types: stats.event_types,
                last_updated: chrono::Utc::now().timestamp(),
            };
            
            self.register_mint(registration).await?;
        }
        
        Ok(())
    }
    
    /// 监听到新事件时注册 mint_account
    pub async fn register_mint_event(&self, event: &SpinPetEvent) -> Result<()> {
        let mint_account = self.extract_mint_account(event);
        
        let registration = MintRegistration {
            mint_account: mint_account.clone(),
            server_id: self.server_id.clone(),
            event_type: event.event_type(),
            timestamp: event.timestamp(),
            slot: event.slot(),
        };
        
        // 异步注册，不阻塞事件处理
        let client = self.clone();
        tokio::spawn(async move {
            if let Err(e) = client.register_mint(registration).await {
                warn!("Failed to register mint event: {}", e);
            }
        });
        
        Ok(())
    }
    
    /// 定期同步本地数据状态
    pub async fn sync_mint_status(&self) -> Result<()> {
        // 每 5 分钟同步一次
        loop {
            if let Err(e) = self.sync_all_mints().await {
                error!("Failed to sync mint status: {}", e);
            }
            
            tokio::time::sleep(Duration::from_secs(300)).await;
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MintRegistration {
    pub mint_account: String,
    pub server_id: String,
    pub data_from: Option<i64>,
    pub data_to: Option<i64>,
    pub event_count: Option<usize>,
    pub event_types: Option<Vec<String>>,
    pub event_type: Option<String>,    // 单个事件注册
    pub timestamp: Option<i64>,        // 单个事件时间
    pub slot: Option<u64>,             // 单个事件槽位
    pub last_updated: i64,
}
```

#### 方案四: 混合查询策略

```rust
// src/services/distributed_query.rs
pub struct DistributedQueryService {
    registry_client: Arc<RegistryClient>,
    local_storage: Arc<EventStorage>,
    peer_clients: HashMap<String, Arc<reqwest::Client>>,
}

impl DistributedQueryService {
    /// 智能查询 mint_account 数据
    pub async fn query_mint_data(&self, 
        mint_account: &str, 
        query: &EventQuery
    ) -> Result<EventQueryResponse> {
        
        // 1. 先查询本地
        if let Ok(local_result) = self.local_storage.query_events(query).await {
            if !local_result.events.is_empty() {
                info!("Found {} events locally for mint: {}", 
                    local_result.events.len(), mint_account);
                return Ok(local_result);
            }
        }
        
        // 2. 查询注册表找到其他服务器
        let servers = self.registry_client
            .find_servers_for_mint(mint_account).await
            .unwrap_or_default();
            
        if servers.is_empty() {
            return Ok(EventQueryResponse::empty());
        }
        
        // 3. 并行查询多个服务器
        let mut query_futures = Vec::new();
        for server in servers {
            let query_clone = query.clone();
            let client = self.peer_clients.get(&server.server_id).cloned();
            
            if let Some(client) = client {
                let future = self.query_remote_server(client, &server, query_clone);
                query_futures.push(future);
            }
        }
        
        let results = futures::future::join_all(query_futures).await;
        
        // 4. 合并结果
        self.merge_query_results(results).await
    }
    
    async fn query_remote_server(&self,
        client: Arc<reqwest::Client>,
        server: &ServerInfo, 
        query: EventQuery
    ) -> Result<EventQueryResponse> {
        
        let url = format!("{}/api/events", server.endpoint);
        let response = client.post(&url)
            .json(&query)
            .timeout(Duration::from_secs(10))
            .send()
            .await?;
            
        if response.status().is_success() {
            let result: EventQueryResponse = response.json().await?;
            info!("Got {} events from server {}", 
                result.events.len(), server.server_id);
            Ok(result)
        } else {
            Err(anyhow::anyhow!("Server {} returned error: {}", 
                server.server_id, response.status()))
        }
    }
    
    async fn merge_query_results(&self, 
        results: Vec<Result<EventQueryResponse>>
    ) -> Result<EventQueryResponse> {
        
        let mut all_events = Vec::new();
        let mut total_count = 0;
        
        for result in results {
            if let Ok(response) = result {
                all_events.extend(response.events);
                total_count += response.total;
            }
        }
        
        // 按时间戳排序去重
        all_events.sort_by_key(|e| (e.slot(), e.signature()));
        all_events.dedup_by_key(|e| e.signature());
        
        Ok(EventQueryResponse {
            events: all_events,
            total: total_count,
            page: 1,
            limit: 100,
            has_next: false,
            has_prev: false,
        })
    }
}
```

## 分布式部署方案

### 方案一: 基于 Cloudflare Workers 的智能路由

#### 架构图
```
客户端 → Cloudflare Workers → 服务器集群
                 ↓
            路由决策层
                 ↓
    [Server1] [Server2] [Server3] ... [ServerN]
```

#### 实现步骤

1. **Cloudflare Workers 路由层**
   ```javascript
   // cloudflare-worker.js
   export default {
     async fetch(request, env, ctx) {
       const url = new URL(request.url);
       const path = url.pathname;
       
       // 提取 mint_account
       const mintAccount = extractMintAccount(request, path);
       
       if (mintAccount) {
         // 基于 mint_account 计算目标服务器
         const targetServer = await getServerForMint(mintAccount, env);
         return await forwardToServer(request, targetServer);
       }
       
       // 通用请求负载均衡
       return await loadBalance(request, env);
     }
   };
   
   function extractMintAccount(request, path) {
     // 从 URL 路径或请求体中提取 mint_account
     if (path.includes('/api/events/') || path.includes('/api/kline/')) {
       const mintMatch = path.match(/mint=([^&]*)/);
       return mintMatch ? mintMatch[1] : null;
     }
     return null;
   }
   ```

2. **一致性哈希分片**
   ```javascript
   async function getServerForMint(mintAccount, env) {
     // 使用一致性哈希算法
     const hash = await crypto.subtle.digest('SHA-256', 
       new TextEncoder().encode(mintAccount));
     const hashHex = Array.from(new Uint8Array(hash))
       .map(b => b.toString(16).padStart(2, '0')).join('');
     
     const serverIndex = parseInt(hashHex.substring(0, 8), 16) % 
       env.SERVER_COUNT;
     
     return env.SERVERS[serverIndex];
   }
   ```

### 方案二: 基于 Cloudflare Load Balancer + Health Check

#### 配置 Cloudflare Load Balancer
1. **创建健康检查**
   - 端点: `/health`
   - 检查间隔: 30秒
   - 超时: 5秒
   - 重试: 2次

2. **配置地理分布**
   ```yaml
   pools:
     - name: "asia-pacific"
       origins:
         - server1-asia.yourdomain.com
         - server2-asia.yourdomain.com
     - name: "north-america" 
       origins:
         - server1-us.yourdomain.com
         - server2-us.yourdomain.com
   ```

3. **智能路由规则**
   ```javascript
   // 在 Cloudflare Workers 中配置
   const routingRules = {
     // mint_account 路由规则
     mintRouting: {
       pattern: /^[A-Za-z0-9]{44}$/, // Solana 地址格式
       strategy: "consistent_hash"
     },
     
     // WebSocket 路由规则  
     websocketRouting: {
       pattern: /^\/ws/,
       strategy: "sticky_session"
     }
   };
   ```

## 数据同步策略

### 方案一: 主动数据复制

#### 跨服务器事件同步
```rust
// src/services/distributed_sync.rs
pub struct DistributedSync {
    peer_servers: Vec<String>,
    http_client: reqwest::Client,
}

impl DistributedSync {
    pub async fn broadcast_event(&self, event: &SpinPetEvent) -> Result<()> {
        let mint_account = self.extract_mint_account(event);
        
        // 发送到其他服务器
        for server in &self.peer_servers {
            if let Err(e) = self.send_event_to_peer(server, event).await {
                warn!("Failed to sync event to {}: {}", server, e);
            }
        }
        
        Ok(())
    }
    
    async fn send_event_to_peer(&self, server: &str, event: &SpinPetEvent) -> Result<()> {
        let url = format!("{}/api/sync/event", server);
        let response = self.http_client
            .post(&url)
            .json(event)
            .send()
            .await?;
            
        if response.status().is_success() {
            debug!("Successfully synced event to {}", server);
        }
        
        Ok(())
    }
}
```

### 方案二: 基于消息队列的异步同步

#### 使用 Cloudflare Queues
```javascript
// 在 Cloudflare Workers 中
export default {
  async queue(batch, env, ctx) {
    // 处理队列中的同步事件
    for (const message of batch.messages) {
      const event = message.body;
      await syncEventToAllServers(event, env);
    }
  }
};
```

## 负载均衡策略

### 1. 基于 mint_account 的分片负载均衡

#### 实现原理
```rust
// src/services/load_balancer.rs
pub struct MintBasedLoadBalancer {
    servers: Vec<ServerInfo>,
    hash_ring: ConsistentHashRing,
}

impl MintBasedLoadBalancer {
    pub fn get_server_for_mint(&self, mint_account: &str) -> &ServerInfo {
        self.hash_ring.get_node(mint_account)
    }
    
    pub fn add_server(&mut self, server: ServerInfo) {
        // 添加到一致性哈希环
        self.hash_ring.add_node(server.clone());
        self.servers.push(server);
    }
    
    pub fn remove_server(&mut self, server_id: &str) {
        // 从哈希环移除
        self.hash_ring.remove_node(server_id);
        self.servers.retain(|s| s.id != server_id);
    }
}
```

### 2. WebSocket 连接的粘性会话

#### Cloudflare Workers 实现
```javascript
async function handleWebSocket(request, env) {
  const url = new URL(request.url);
  const mintAccount = url.searchParams.get('mint');
  
  if (mintAccount) {
    // 基于 mint_account 选择服务器
    const targetServer = await getServerForMint(mintAccount, env);
    return await upgradeWebSocket(request, targetServer);
  }
  
  // 使用会话保持
  const sessionId = request.headers.get('CF-Connecting-IP');
  const targetServer = await getServerBySession(sessionId, env);
  return await upgradeWebSocket(request, targetServer);
}
```

## 健康检查和故障转移

### 1. 健康检查端点
```rust
// src/handlers/health.rs
pub async fn health_check(
    State(app_state): State<AppState>,
) -> Json<HealthStatus> {
    let status = HealthStatus {
        server_id: app_state.server_id.clone(),
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now(),
        
        // 关键指标
        active_connections: app_state.websocket_manager.connection_count(),
        rocksdb_status: check_rocksdb_health(&app_state.event_storage).await,
        solana_listener_status: app_state.solana_listener.is_healthy(),
        
        // mint_account 统计
        mint_count: app_state.event_storage.get_mint_count().await.unwrap_or(0),
        recent_events_count: app_state.event_storage
            .get_recent_events_count(Duration::from_secs(60)).await.unwrap_or(0),
    };
    
    Json(status)
}
```

### 2. 故障转移机制
```javascript
// Cloudflare Workers 故障转移
async function handleFailover(mintAccount, failedServer, env) {
  // 标记服务器故障
  await env.FAILED_SERVERS.put(failedServer, Date.now().toString(), {
    expirationTtl: 300 // 5分钟后重试
  });
  
  // 重新计算目标服务器
  const availableServers = env.SERVERS.filter(s => s !== failedServer);
  const backupServer = await getServerForMint(mintAccount, {
    ...env,
    SERVERS: availableServers
  });
  
  return backupServer;
}
```

## 服务器配置修改

### 1. 添加服务器标识
```rust
// src/config.rs
#[derive(Debug, Deserialize)]
pub struct Config {
    pub server: ServerConfig,
    // ... 其他配置
}

#[derive(Debug, Deserialize)]
pub struct ServerConfig {
    pub server_id: String,           // 唯一服务器标识
    pub cluster_mode: bool,          // 是否启用集群模式
    pub peer_servers: Vec<String>,   // 集群中其他服务器地址
    pub sync_enabled: bool,          // 是否启用数据同步
}
```

### 2. 配置文件示例
```toml
# config/production.toml
[server]
host = "0.0.0.0"
port = 8080
server_id = "server-001"
cluster_mode = true
peer_servers = [
    "https://server-002.yourdomain.com",
    "https://server-003.yourdomain.com"
]
sync_enabled = true

[database]
path = "./data/rocksdb"

[solana]
rpc_url = "https://api.mainnet-beta.solana.com"
websocket_url = "wss://api.mainnet-beta.solana.com"
```

## 部署流程

### 1. 服务器部署
```bash
#!/bin/bash
# deploy.sh

# 构建 Docker 镜像
docker build -t spin-server:latest .

# 部署到不同区域
regions=("us-west" "us-east" "asia-pacific" "europe")

for region in "${regions[@]}"; do
  echo "Deploying to $region..."
  
  # 生成区域特定配置
  envsubst < config/template.toml > config/$region.toml
  
  # 部署到云服务商
  deploy_to_region "$region" "spin-server:latest"
done
```

### 2. Cloudflare Workers 部署
```bash
# 部署路由 Worker
npx wrangler publish cloudflare-worker.js

# 配置环境变量
wrangler secret put SERVER_COUNT
wrangler secret put SERVERS
```

## 监控和观察性

### 1. 指标收集
```rust
// src/metrics.rs
use prometheus::{Counter, Histogram, Registry};

lazy_static! {
    pub static ref REQUEST_COUNTER: Counter = Counter::new(
        "spin_server_requests_total", 
        "Total number of requests"
    ).unwrap();
    
    pub static ref MINT_QUERY_HISTOGRAM: Histogram = Histogram::new(
        "spin_server_mint_query_duration_seconds",
        "Time spent querying mint data"
    ).unwrap();
}

pub fn init_metrics() -> Registry {
    let registry = Registry::new();
    registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();
    registry.register(Box::new(MINT_QUERY_HISTOGRAM.clone())).unwrap();
    registry
}
```

### 2. 日志聚合
- 使用 Cloudflare Analytics Engine 收集请求日志
- 配置 structured logging 便于分析
- 监控关键指标: 延迟、错误率、mint_account 分布

## 成本优化建议

### 1. 资源层次化
- **热数据服务器**: 高性能 SSD，处理最近 7 天数据
- **温数据服务器**: 普通 SSD，处理 7-30 天数据  
- **冷数据服务器**: 便宜存储，处理历史数据

### 2. 按需扩容
```javascript
// Cloudflare Workers 自动扩容
async function autoScale(env) {
  const metrics = await fetchClusterMetrics(env);
  
  if (metrics.avgCpuUsage > 80 && metrics.activeConnections > 1000) {
    // 触发扩容
    await scaleUp(env);
  } else if (metrics.avgCpuUsage < 20 && metrics.activeConnections < 100) {
    // 触发缩容
    await scaleDown(env);
  }
}
```

## 数据缺失处理策略

### 冷启动问题解决

#### 1. 历史数据同步机制

```rust
// src/services/data_sync.rs
pub struct DataSyncService {
    local_storage: Arc<EventStorage>,
    peer_clients: HashMap<String, reqwest::Client>,
    sync_config: SyncConfig,
}

#[derive(Debug, Clone)]
pub struct SyncConfig {
    pub batch_size: usize,           // 每次同步的事件数量
    pub max_parallel_syncs: usize,   // 最大并行同步任务数
    pub sync_interval: Duration,     // 同步间隔
    pub backfill_enabled: bool,      // 是否启用回填历史数据
}

impl DataSyncService {
    /// 启动时检查并回填缺失数据
    pub async fn startup_sync(&self) -> Result<()> {
        info!("🔄 Starting data synchronization...");
        
        // 1. 获取其他服务器的 mint_account 列表
        let peer_mints = self.get_all_peer_mints().await?;
        
        // 2. 对比本地缺失的 mint_account
        let local_mints = self.local_storage.get_all_mints().await?;
        let missing_mints: Vec<String> = peer_mints.into_iter()
            .filter(|mint| !local_mints.contains(mint))
            .collect();
            
        info!("📥 Found {} missing mints to sync", missing_mints.len());
        
        // 3. 分批同步缺失数据
        for chunk in missing_mints.chunks(self.sync_config.batch_size) {
            let sync_futures: Vec<_> = chunk.iter()
                .map(|mint| self.sync_mint_data(mint))
                .collect();
                
            futures::future::join_all(sync_futures).await;
            
            // 避免过载
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
        
        info!("✅ Data synchronization completed");
        Ok(())
    }
    
    /// 同步特定 mint_account 的数据
    async fn sync_mint_data(&self, mint_account: &str) -> Result<()> {
        // 1. 找到有这个 mint 数据的服务器
        let source_servers = self.find_data_sources(mint_account).await?;
        
        if source_servers.is_empty() {
            warn!("⚠️ No data source found for mint: {}", mint_account);
            return Ok(());
        }
        
        // 2. 选择最完整的数据源
        let best_source = source_servers.iter()
            .max_by_key(|s| s.event_count)
            .unwrap();
            
        info!("📡 Syncing mint {} from server {}", 
            mint_account, best_source.server_id);
            
        // 3. 分页获取所有数据
        let mut page = 1;
        let page_size = 1000;
        
        loop {
            let events = self.fetch_events_from_peer(
                &best_source.endpoint, 
                mint_account, 
                page, 
                page_size
            ).await?;
            
            if events.is_empty() {
                break;
            }
            
            // 4. 批量插入本地存储
            for event in &events {
                if let Err(e) = self.local_storage.store_event(event).await {
                    warn!("Failed to store synced event: {}", e);
                }
            }
            
            info!("📥 Synced page {} ({} events) for mint {}", 
                page, events.len(), mint_account);
                
            page += 1;
            
            if events.len() < page_size {
                break; // Last page
            }
        }
        
        Ok(())
    }
    
    async fn get_all_peer_mints(&self) -> Result<Vec<String>> {
        let mut all_mints = HashSet::new();
        
        let futures: Vec<_> = self.peer_clients.iter()
            .map(|(server_id, client)| {
                self.fetch_mint_list(server_id, client)
            })
            .collect();
            
        let results = futures::future::join_all(futures).await;
        
        for result in results {
            if let Ok(mints) = result {
                all_mints.extend(mints);
            }
        }
        
        Ok(all_mints.into_iter().collect())
    }
}
```

#### 2. 智能数据路由

```javascript
// 在 Cloudflare Workers 中处理数据缺失
async function handleMissingData(mintAccount, request, env) {
  console.log(`🔍 Searching for mint data: ${mintAccount}`);
  
  // 1. 广播到所有健康服务器
  const searchPromises = env.SERVERS.map(async server => {
    if (await isServerHealthy(server, env)) {
      return await searchMintOnServer(server, mintAccount, request);
    }
    return null;
  });
  
  const searchResults = await Promise.allSettled(searchPromises);
  
  // 2. 收集所有找到数据的服务器
  const foundServers = [];
  for (const result of searchResults) {
    if (result.status === 'fulfilled' && result.value) {
      foundServers.push(result.value);
    }
  }
  
  if (foundServers.length === 0) {
    return new Response(JSON.stringify({
      error: 'mint_not_found',
      mint_account: mintAccount,
      message: 'This mint account was not found on any server',
      suggestion: 'The mint may not exist or servers are still syncing'
    }), { status: 404 });
  }
  
  // 3. 选择最佳数据源并更新注册表
  const bestServer = selectBestDataSource(foundServers);
  await updateMintRegistry(mintAccount, bestServer, env);
  
  // 4. 转发到最佳服务器
  return await forwardToServer(request, bestServer);
}

async function searchMintOnServer(server, mintAccount, request) {
  try {
    const searchUrl = new URL(request.url);
    searchUrl.hostname = server.hostname;
    searchUrl.port = server.port || '';
    
    // 添加检查参数，只查询是否存在，不返回大量数据
    searchUrl.searchParams.set('check_only', 'true');
    searchUrl.searchParams.set('limit', '1');
    
    const response = await fetch(searchUrl.toString(), {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'User-Agent': 'Cloudflare-Worker-Router/1.0'
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      if (data.total > 0) {
        return {
          server: server,
          event_count: data.total,
          last_updated: Date.now()
        };
      }
    }
    
    return null;
  } catch (error) {
    console.error(`Error searching mint on ${server.hostname}: ${error}`);
    return null;
  }
}

function selectBestDataSource(foundServers) {
  // 选择数据最多的服务器
  return foundServers.reduce((best, current) => {
    return current.event_count > best.event_count ? current : best;
  });
}
```

#### 3. 渐进式数据发现

```rust
// src/services/progressive_discovery.rs
pub struct ProgressiveDiscoveryService {
    local_storage: Arc<EventStorage>,
    registry_client: Arc<RegistryClient>,
    discovery_cache: Arc<RwLock<HashMap<String, DiscoveryResult>>>,
}

#[derive(Debug, Clone)]
struct DiscoveryResult {
    servers_checked: Vec<String>,
    data_found: bool,
    best_server: Option<String>,
    last_check: i64,
    check_count: usize,
}

impl ProgressiveDiscoveryService {
    /// 渐进式查找 mint_account 数据
    pub async fn discover_mint(&self, mint_account: &str) -> Result<Option<String>> {
        // 1. 检查缓存
        if let Some(cached) = self.get_cached_result(mint_account).await {
            if !self.should_refresh_cache(&cached) {
                return Ok(cached.best_server.clone());
            }
        }
        
        // 2. 快速本地检查
        if self.local_storage.has_mint_data(mint_account).await? {
            return Ok(Some("local".to_string()));
        }
        
        // 3. 查询注册表
        if let Some(servers) = self.registry_client
            .find_servers_for_mint(mint_account).await {
            if !servers.is_empty() {
                let best_server = servers[0].endpoint.clone();
                self.cache_discovery_result(mint_account, servers).await;
                return Ok(Some(best_server));
            }
        }
        
        // 4. 广播搜索（最后手段）
        self.broadcast_search(mint_account).await
    }
    
    async fn broadcast_search(&self, mint_account: &str) -> Result<Option<String>> {
        info!("🔍 Broadcasting search for mint: {}", mint_account);
        
        // 实现智能搜索策略：
        // - 优先搜索最近活跃的服务器
        // - 按地理位置就近搜索
        // - 避免重复搜索已确认没有数据的服务器
        
        let mut discovery_result = DiscoveryResult {
            servers_checked: Vec::new(),
            data_found: false,
            best_server: None,
            last_check: chrono::Utc::now().timestamp(),
            check_count: 1,
        };
        
        // 分批搜索，避免雪崩
        let peer_servers = self.get_prioritized_peer_list().await?;
        
        for batch in peer_servers.chunks(3) {  // 每批3个服务器
            let search_futures: Vec<_> = batch.iter()
                .map(|server| self.search_server_for_mint(server, mint_account))
                .collect();
                
            let results = futures::future::join_all(search_futures).await;
            
            for (i, result) in results.into_iter().enumerate() {
                let server = &batch[i];
                discovery_result.servers_checked.push(server.clone());
                
                if let Ok(Some(server_endpoint)) = result {
                    discovery_result.data_found = true;
                    discovery_result.best_server = Some(server_endpoint.clone());
                    
                    // 立即更新注册表
                    let _ = self.registry_client.register_mint_discovery(
                        mint_account, &server_endpoint
                    ).await;
                    
                    break;
                }
            }
            
            if discovery_result.data_found {
                break;
            }
            
            // 批次间延迟
            tokio::time::sleep(Duration::from_millis(200)).await;
        }
        
        // 缓存搜索结果（包括未找到的结果）
        self.cache_discovery_result(mint_account, vec![]).await;
        
        Ok(discovery_result.best_server)
    }
    
    /// 智能缓存策略
    fn should_refresh_cache(&self, result: &DiscoveryResult) -> bool {
        let now = chrono::Utc::now().timestamp();
        let age = now - result.last_check;
        
        // 根据查找结果调整缓存时间
        let max_age = if result.data_found {
            3600  // 找到数据：缓存1小时
        } else {
            300   // 未找到：缓存5分钟（可能是新mint）
        };
        
        age > max_age || (result.check_count < 3 && age > 60)
    }
}
```

### 数据一致性保障

#### 1. 最终一致性策略
- **写入确认**: 事件写入后异步同步到其他节点
- **读取修复**: 读取时检测数据不一致并修复
- **定期校验**: 后台任务定期校验数据完整性

#### 2. 冲突解决机制
- **时间戳优先**: 使用区块链槽位号作为权威时间戳
- **数据合并**: 同一事件的重复数据自动去重
- **版本向量**: 跟踪每个服务器的数据版本

## 总结

通过以上分布式架构设计，可以实现:

1. **高可用性**: 多区域部署，自动故障转移
2. **可扩展性**: 基于 mint_account 的水平分片  
3. **动态发现**: 智能路由和数据发现机制
4. **数据一致**: 渐进式同步和冲突解决
5. **性能优化**: Cloudflare 边缘计算加速
6. **成本控制**: 按需扩容，资源层次化

### 实施路线图

**第一阶段: 基础架构** (2-3周)
1. 实现 Cloudflare Workers 智能路由
2. 添加服务器注册和发现机制
3. 建立健康检查和故障转移

**第二阶段: 数据管理** (3-4周)
1. 实现分布式数据索引
2. 添加渐进式数据发现
3. 建立数据同步机制

**第三阶段: 优化增强** (2-3周)
1. 性能优化和缓存策略
2. 监控告警和自动化运维
3. 成本优化和资源管理

**第四阶段: 生产部署** (1-2周)
1. 灰度发布和A/B测试
2. 生产环境优化
3. 文档和培训
