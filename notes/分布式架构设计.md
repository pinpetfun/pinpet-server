# Spin Server åˆ†å¸ƒå¼æ¶æ„è®¾è®¡

## æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°å¦‚ä½•å°† Spin Server éƒ¨ç½²ä¸ºåˆ†å¸ƒå¼ç³»ç»Ÿï¼Œä½¿ç”¨ Cloudflare ä½œä¸ºåè°ƒå±‚æ¥ç®¡ç†å¤šå°æœåŠ¡å™¨å®ä¾‹ï¼Œç‰¹åˆ«æ˜¯å¤„ç† mint_account ç›¸å…³æ•°æ®çš„åˆ†ç‰‡å’Œè´Ÿè½½å‡è¡¡ã€‚

## å½“å‰æ¶æ„åˆ†æ

### æ•°æ®ç‰¹å¾
- **æ ¸å¿ƒæ•°æ®ç»´åº¦**: mint_account (ä»£å¸é“¸å¸åœ°å€)
- **å­˜å‚¨å¼•æ“**: RocksDB (æœ¬åœ°é”®å€¼å­˜å‚¨)
- **æ•°æ®å‰ç¼€**:
  - `mt:` - Token markers
  - `tr:` - Transaction events  
  - `or:` - Order data
  - `us:` - User events
  - `in:` - Token info

### æ•°æ®åˆ†ç‰‡å¤©ç„¶æ€§
- æ¯ä¸ª mint_account çš„æ•°æ®ç›¸å¯¹ç‹¬ç«‹
- äº¤æ˜“äº‹ä»¶ã€è®¢å•æ•°æ®éƒ½æŒ‰ mint_account ç»„ç»‡
- WebSocket è®¢é˜…ä¹Ÿæ˜¯åŸºäº mint_account è¿›è¡Œçš„

## æ ¸å¿ƒæŒ‘æˆ˜ï¼šåŠ¨æ€æ•°æ®åˆ†å¸ƒé—®é¢˜

### é—®é¢˜åˆ†æ
æ¯å°æœåŠ¡å™¨å¯åŠ¨æ—¶é—´ä¸åŒï¼Œç›‘å¬åˆ°çš„åŒºå—é“¾äº‹ä»¶ä¹Ÿä¸åŒï¼Œå¯¼è‡´ï¼š

1. **æ•°æ®åˆ†å¸ƒä¸å‡**: æ—©å¯åŠ¨çš„æœåŠ¡å™¨å¯èƒ½æœ‰æ›´å¤šå†å² mint_account
2. **æ•°æ®åˆ†æ•£**: åŒä¸€ä¸ª mint_account çš„ä¸åŒæ—¶é—´æ®µæ•°æ®å¯èƒ½åœ¨ä¸åŒæœåŠ¡å™¨ä¸Š
3. **åŠ¨æ€æ€§**: æ–°çš„ mint_account ä¼šéšæ—¶å‡ºç°ï¼Œæ— æ³•é¢„å…ˆåˆ†é…
4. **æŸ¥è¯¢å›°éš¾**: å®¢æˆ·ç«¯ä¸çŸ¥é“æŸä¸ª mint_account çš„æ•°æ®åœ¨å“ªå°æœåŠ¡å™¨ä¸Š

### è§£å†³æ–¹æ¡ˆï¼šåˆ†å¸ƒå¼æ•°æ®ç´¢å¼• + åŠ¨æ€è·¯ç”±

#### æ–¹æ¡ˆä¸€: å…¨å±€æ•°æ®ç´¢å¼•æœåŠ¡

```rust
// src/services/mint_registry.rs
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MintServerMapping {
    pub mint_account: String,
    pub servers: Vec<ServerInfo>,        // å“ªäº›æœåŠ¡å™¨æœ‰è¿™ä¸ª mint çš„æ•°æ®
    pub data_ranges: Vec<DataRange>,     // æ¯ä¸ªæœåŠ¡å™¨çš„æ•°æ®æ—¶é—´èŒƒå›´
    pub last_updated: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerInfo {
    pub server_id: String,
    pub endpoint: String,
    pub health_status: String,
    pub data_from: i64,                  // è¯¥æœåŠ¡å™¨æ•°æ®èµ·å§‹æ—¶é—´
    pub data_to: i64,                    // è¯¥æœåŠ¡å™¨æ•°æ®ç»“æŸæ—¶é—´
    pub event_count: usize,              // è¯¥ mint åœ¨æ­¤æœåŠ¡å™¨çš„äº‹ä»¶æ•°é‡
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataRange {
    pub server_id: String,
    pub start_slot: u64,
    pub end_slot: u64,
    pub event_types: Vec<String>,        // è¯¥æœåŠ¡å™¨æœ‰å“ªäº›äº‹ä»¶ç±»å‹
}

/// å…¨å±€ mint æ³¨å†Œè¡¨æœåŠ¡
pub struct MintRegistry {
    // ä½¿ç”¨ Cloudflare D1 æˆ–è€… KV å­˜å‚¨
    mappings: HashMap<String, MintServerMapping>,
    http_client: reqwest::Client,
}

impl MintRegistry {
    /// æ³¨å†Œæ–°çš„ mint_account åˆ°æœåŠ¡å™¨æ˜ å°„
    pub async fn register_mint(&mut self, 
        mint_account: String, 
        server_info: ServerInfo,
        data_range: DataRange
    ) -> Result<()> {
        let mapping = self.mappings.entry(mint_account.clone())
            .or_insert_with(|| MintServerMapping {
                mint_account: mint_account.clone(),
                servers: Vec::new(),
                data_ranges: Vec::new(),
                last_updated: chrono::Utc::now().timestamp(),
            });
        
        // æ›´æ–°æˆ–æ·»åŠ æœåŠ¡å™¨ä¿¡æ¯
        if let Some(existing) = mapping.servers.iter_mut()
            .find(|s| s.server_id == server_info.server_id) {
            *existing = server_info;
        } else {
            mapping.servers.push(server_info);
        }
        
        // æ›´æ–°æ•°æ®èŒƒå›´
        if let Some(existing) = mapping.data_ranges.iter_mut()
            .find(|r| r.server_id == data_range.server_id) {
            *existing = data_range;
        } else {
            mapping.data_ranges.push(data_range);
        }
        
        mapping.last_updated = chrono::Utc::now().timestamp();
        
        // æŒä¹…åŒ–åˆ° Cloudflare KV
        self.persist_mapping(&mint_account, mapping).await?;
        
        Ok(())
    }
    
    /// æŸ¥æ‰¾ mint_account å¯¹åº”çš„æœåŠ¡å™¨
    pub async fn find_servers_for_mint(&self, mint_account: &str) -> Option<Vec<ServerInfo>> {
        if let Some(mapping) = self.mappings.get(mint_account) {
            // è¿‡æ»¤å¥åº·çš„æœåŠ¡å™¨
            let healthy_servers: Vec<ServerInfo> = mapping.servers.iter()
                .filter(|s| s.health_status == "healthy")
                .cloned()
                .collect();
            
            if !healthy_servers.is_empty() {
                return Some(healthy_servers);
            }
        }
        
        // ä»æŒä¹…åŒ–å­˜å‚¨æŸ¥è¯¢
        self.load_mapping_from_storage(mint_account).await
    }
    
    /// æ™ºèƒ½é€‰æ‹©æœ€ä½³æœåŠ¡å™¨
    pub fn select_best_server(&self, servers: &[ServerInfo], query_type: &str) -> Option<&ServerInfo> {
        match query_type {
            "latest" => {
                // é€‰æ‹©æ•°æ®æœ€æ–°çš„æœåŠ¡å™¨
                servers.iter().max_by_key(|s| s.data_to)
            },
            "complete" => {
                // é€‰æ‹©æ•°æ®æœ€å®Œæ•´çš„æœåŠ¡å™¨
                servers.iter().max_by_key(|s| s.event_count)
            },
            "range" => {
                // é€‰æ‹©æ•°æ®èŒƒå›´æœ€å¹¿çš„æœåŠ¡å™¨
                servers.iter().max_by_key(|s| s.data_to - s.data_from)
            },
            _ => servers.first()
        }
    }
}
```

#### æ–¹æ¡ˆäºŒ: Cloudflare Workers å®ç°åŠ¨æ€è·¯ç”±

```javascript
// cloudflare-worker-advanced.js
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const mintAccount = extractMintAccount(request, url);
    
    if (mintAccount) {
      return await handleMintRequest(request, mintAccount, env);
    }
    
    return await defaultLoadBalance(request, env);
  }
};

async function handleMintRequest(request, mintAccount, env) {
  try {
    // 1. æŸ¥è¯¢ mint_account çš„æœåŠ¡å™¨æ˜ å°„
    const servers = await findServersForMint(mintAccount, env);
    
    if (servers.length === 0) {
      // æ²¡æœ‰æœåŠ¡å™¨æœ‰è¿™ä¸ª mint çš„æ•°æ®ï¼Œå¹¿æ’­æŸ¥è¯¢
      return await broadcastMintQuery(request, mintAccount, env);
    }
    
    // 2. é€‰æ‹©æœ€ä½³æœåŠ¡å™¨
    const targetServer = selectBestServer(servers, request);
    
    // 3. è½¬å‘è¯·æ±‚
    const response = await forwardToServer(request, targetServer);
    
    // 4. å¦‚æœå¤±è´¥ï¼Œå°è¯•å…¶ä»–æœåŠ¡å™¨
    if (!response.ok && servers.length > 1) {
      return await tryOtherServers(request, servers, targetServer);
    }
    
    return response;
    
  } catch (error) {
    console.error(`Error handling mint request: ${error}`);
    return new Response('Service Unavailable', { status: 503 });
  }
}

async function findServersForMint(mintAccount, env) {
  // ä» Cloudflare KV æŸ¥è¯¢
  const mappingKey = `mint:${mintAccount}`;
  const mappingStr = await env.MINT_REGISTRY.get(mappingKey);
  
  if (!mappingStr) {
    return [];
  }
  
  const mapping = JSON.parse(mappingStr);
  
  // è¿‡æ»¤å¥åº·çš„æœåŠ¡å™¨
  const healthyServers = [];
  for (const server of mapping.servers) {
    if (await isServerHealthy(server, env)) {
      healthyServers.push(server);
    }
  }
  
  return healthyServers;
}

async function broadcastMintQuery(request, mintAccount, env) {
  console.log(`Broadcasting query for mint: ${mintAccount}`);
  
  // å¹¶è¡ŒæŸ¥è¯¢æ‰€æœ‰æœåŠ¡å™¨
  const promises = env.SERVERS.map(server => 
    queryServerForMint(request, server, mintAccount)
  );
  
  const results = await Promise.allSettled(promises);
  
  // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæˆåŠŸçš„å“åº”
  for (const result of results) {
    if (result.status === 'fulfilled' && result.value.ok) {
      // æ›´æ–°æ³¨å†Œè¡¨
      await updateMintRegistry(mintAccount, result.value.server, env);
      return result.value.response;
    }
  }
  
  return new Response(JSON.stringify({
    error: 'mint_account not found',
    mint_account: mintAccount,
    message: 'No server has data for this mint account'
  }), { 
    status: 404,
    headers: { 'Content-Type': 'application/json' }
  });
}

async function queryServerForMint(request, server, mintAccount) {
  try {
    const serverUrl = new URL(request.url);
    serverUrl.hostname = server.hostname;
    serverUrl.port = server.port || '';
    
    const response = await fetch(serverUrl.toString(), {
      method: request.method,
      headers: request.headers,
      body: request.body
    });
    
    return {
      ok: response.ok,
      server: server,
      response: response
    };
  } catch (error) {
    return {
      ok: false,
      server: server,
      error: error.message
    };
  }
}

async function updateMintRegistry(mintAccount, server, env) {
  const mappingKey = `mint:${mintAccount}`;
  const now = Date.now();
  
  let mapping;
  const existing = await env.MINT_REGISTRY.get(mappingKey);
  
  if (existing) {
    mapping = JSON.parse(existing);
  } else {
    mapping = {
      mint_account: mintAccount,
      servers: [],
      last_updated: now
    };
  }
  
  // æ·»åŠ æˆ–æ›´æ–°æœåŠ¡å™¨ä¿¡æ¯
  const serverIndex = mapping.servers.findIndex(s => s.id === server.id);
  if (serverIndex >= 0) {
    mapping.servers[serverIndex].last_seen = now;
  } else {
    mapping.servers.push({
      id: server.id,
      hostname: server.hostname,
      port: server.port,
      first_seen: now,
      last_seen: now
    });
  }
  
  mapping.last_updated = now;
  
  // ä¿å­˜åˆ° KVï¼Œè®¾ç½® 24 å°æ—¶è¿‡æœŸ
  await env.MINT_REGISTRY.put(mappingKey, JSON.stringify(mapping), {
    expirationTtl: 86400
  });
}
```

#### æ–¹æ¡ˆä¸‰: æœåŠ¡å™¨ç«¯ä¸»åŠ¨æ³¨å†Œ

```rust
// src/services/registry_client.rs
pub struct RegistryClient {
    registry_endpoint: String,
    server_id: String,
    http_client: reqwest::Client,
}

impl RegistryClient {
    /// å¯åŠ¨æ—¶æ³¨å†Œæœ¬æœåŠ¡å™¨çš„æ‰€æœ‰ mint_account
    pub async fn register_all_mints(&self, event_storage: &EventStorage) -> Result<()> {
        let mints = event_storage.get_all_mints().await?;
        
        for mint in mints {
            let stats = event_storage.get_mint_stats(&mint).await?;
            
            let registration = MintRegistration {
                mint_account: mint.clone(),
                server_id: self.server_id.clone(),
                data_from: stats.first_event_time,
                data_to: stats.last_event_time,
                event_count: stats.total_events,
                event_types: stats.event_types,
                last_updated: chrono::Utc::now().timestamp(),
            };
            
            self.register_mint(registration).await?;
        }
        
        Ok(())
    }
    
    /// ç›‘å¬åˆ°æ–°äº‹ä»¶æ—¶æ³¨å†Œ mint_account
    pub async fn register_mint_event(&self, event: &SpinPetEvent) -> Result<()> {
        let mint_account = self.extract_mint_account(event);
        
        let registration = MintRegistration {
            mint_account: mint_account.clone(),
            server_id: self.server_id.clone(),
            event_type: event.event_type(),
            timestamp: event.timestamp(),
            slot: event.slot(),
        };
        
        // å¼‚æ­¥æ³¨å†Œï¼Œä¸é˜»å¡äº‹ä»¶å¤„ç†
        let client = self.clone();
        tokio::spawn(async move {
            if let Err(e) = client.register_mint(registration).await {
                warn!("Failed to register mint event: {}", e);
            }
        });
        
        Ok(())
    }
    
    /// å®šæœŸåŒæ­¥æœ¬åœ°æ•°æ®çŠ¶æ€
    pub async fn sync_mint_status(&self) -> Result<()> {
        // æ¯ 5 åˆ†é’ŸåŒæ­¥ä¸€æ¬¡
        loop {
            if let Err(e) = self.sync_all_mints().await {
                error!("Failed to sync mint status: {}", e);
            }
            
            tokio::time::sleep(Duration::from_secs(300)).await;
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MintRegistration {
    pub mint_account: String,
    pub server_id: String,
    pub data_from: Option<i64>,
    pub data_to: Option<i64>,
    pub event_count: Option<usize>,
    pub event_types: Option<Vec<String>>,
    pub event_type: Option<String>,    // å•ä¸ªäº‹ä»¶æ³¨å†Œ
    pub timestamp: Option<i64>,        // å•ä¸ªäº‹ä»¶æ—¶é—´
    pub slot: Option<u64>,             // å•ä¸ªäº‹ä»¶æ§½ä½
    pub last_updated: i64,
}
```

#### æ–¹æ¡ˆå››: æ··åˆæŸ¥è¯¢ç­–ç•¥

```rust
// src/services/distributed_query.rs
pub struct DistributedQueryService {
    registry_client: Arc<RegistryClient>,
    local_storage: Arc<EventStorage>,
    peer_clients: HashMap<String, Arc<reqwest::Client>>,
}

impl DistributedQueryService {
    /// æ™ºèƒ½æŸ¥è¯¢ mint_account æ•°æ®
    pub async fn query_mint_data(&self, 
        mint_account: &str, 
        query: &EventQuery
    ) -> Result<EventQueryResponse> {
        
        // 1. å…ˆæŸ¥è¯¢æœ¬åœ°
        if let Ok(local_result) = self.local_storage.query_events(query).await {
            if !local_result.events.is_empty() {
                info!("Found {} events locally for mint: {}", 
                    local_result.events.len(), mint_account);
                return Ok(local_result);
            }
        }
        
        // 2. æŸ¥è¯¢æ³¨å†Œè¡¨æ‰¾åˆ°å…¶ä»–æœåŠ¡å™¨
        let servers = self.registry_client
            .find_servers_for_mint(mint_account).await
            .unwrap_or_default();
            
        if servers.is_empty() {
            return Ok(EventQueryResponse::empty());
        }
        
        // 3. å¹¶è¡ŒæŸ¥è¯¢å¤šä¸ªæœåŠ¡å™¨
        let mut query_futures = Vec::new();
        for server in servers {
            let query_clone = query.clone();
            let client = self.peer_clients.get(&server.server_id).cloned();
            
            if let Some(client) = client {
                let future = self.query_remote_server(client, &server, query_clone);
                query_futures.push(future);
            }
        }
        
        let results = futures::future::join_all(query_futures).await;
        
        // 4. åˆå¹¶ç»“æœ
        self.merge_query_results(results).await
    }
    
    async fn query_remote_server(&self,
        client: Arc<reqwest::Client>,
        server: &ServerInfo, 
        query: EventQuery
    ) -> Result<EventQueryResponse> {
        
        let url = format!("{}/api/events", server.endpoint);
        let response = client.post(&url)
            .json(&query)
            .timeout(Duration::from_secs(10))
            .send()
            .await?;
            
        if response.status().is_success() {
            let result: EventQueryResponse = response.json().await?;
            info!("Got {} events from server {}", 
                result.events.len(), server.server_id);
            Ok(result)
        } else {
            Err(anyhow::anyhow!("Server {} returned error: {}", 
                server.server_id, response.status()))
        }
    }
    
    async fn merge_query_results(&self, 
        results: Vec<Result<EventQueryResponse>>
    ) -> Result<EventQueryResponse> {
        
        let mut all_events = Vec::new();
        let mut total_count = 0;
        
        for result in results {
            if let Ok(response) = result {
                all_events.extend(response.events);
                total_count += response.total;
            }
        }
        
        // æŒ‰æ—¶é—´æˆ³æ’åºå»é‡
        all_events.sort_by_key(|e| (e.slot(), e.signature()));
        all_events.dedup_by_key(|e| e.signature());
        
        Ok(EventQueryResponse {
            events: all_events,
            total: total_count,
            page: 1,
            limit: 100,
            has_next: false,
            has_prev: false,
        })
    }
}
```

## åˆ†å¸ƒå¼éƒ¨ç½²æ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€: åŸºäº Cloudflare Workers çš„æ™ºèƒ½è·¯ç”±

#### æ¶æ„å›¾
```
å®¢æˆ·ç«¯ â†’ Cloudflare Workers â†’ æœåŠ¡å™¨é›†ç¾¤
                 â†“
            è·¯ç”±å†³ç­–å±‚
                 â†“
    [Server1] [Server2] [Server3] ... [ServerN]
```

#### å®ç°æ­¥éª¤

1. **Cloudflare Workers è·¯ç”±å±‚**
   ```javascript
   // cloudflare-worker.js
   export default {
     async fetch(request, env, ctx) {
       const url = new URL(request.url);
       const path = url.pathname;
       
       // æå– mint_account
       const mintAccount = extractMintAccount(request, path);
       
       if (mintAccount) {
         // åŸºäº mint_account è®¡ç®—ç›®æ ‡æœåŠ¡å™¨
         const targetServer = await getServerForMint(mintAccount, env);
         return await forwardToServer(request, targetServer);
       }
       
       // é€šç”¨è¯·æ±‚è´Ÿè½½å‡è¡¡
       return await loadBalance(request, env);
     }
   };
   
   function extractMintAccount(request, path) {
     // ä» URL è·¯å¾„æˆ–è¯·æ±‚ä½“ä¸­æå– mint_account
     if (path.includes('/api/events/') || path.includes('/api/kline/')) {
       const mintMatch = path.match(/mint=([^&]*)/);
       return mintMatch ? mintMatch[1] : null;
     }
     return null;
   }
   ```

2. **ä¸€è‡´æ€§å“ˆå¸Œåˆ†ç‰‡**
   ```javascript
   async function getServerForMint(mintAccount, env) {
     // ä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•
     const hash = await crypto.subtle.digest('SHA-256', 
       new TextEncoder().encode(mintAccount));
     const hashHex = Array.from(new Uint8Array(hash))
       .map(b => b.toString(16).padStart(2, '0')).join('');
     
     const serverIndex = parseInt(hashHex.substring(0, 8), 16) % 
       env.SERVER_COUNT;
     
     return env.SERVERS[serverIndex];
   }
   ```

### æ–¹æ¡ˆäºŒ: åŸºäº Cloudflare Load Balancer + Health Check

#### é…ç½® Cloudflare Load Balancer
1. **åˆ›å»ºå¥åº·æ£€æŸ¥**
   - ç«¯ç‚¹: `/health`
   - æ£€æŸ¥é—´éš”: 30ç§’
   - è¶…æ—¶: 5ç§’
   - é‡è¯•: 2æ¬¡

2. **é…ç½®åœ°ç†åˆ†å¸ƒ**
   ```yaml
   pools:
     - name: "asia-pacific"
       origins:
         - server1-asia.yourdomain.com
         - server2-asia.yourdomain.com
     - name: "north-america" 
       origins:
         - server1-us.yourdomain.com
         - server2-us.yourdomain.com
   ```

3. **æ™ºèƒ½è·¯ç”±è§„åˆ™**
   ```javascript
   // åœ¨ Cloudflare Workers ä¸­é…ç½®
   const routingRules = {
     // mint_account è·¯ç”±è§„åˆ™
     mintRouting: {
       pattern: /^[A-Za-z0-9]{44}$/, // Solana åœ°å€æ ¼å¼
       strategy: "consistent_hash"
     },
     
     // WebSocket è·¯ç”±è§„åˆ™  
     websocketRouting: {
       pattern: /^\/ws/,
       strategy: "sticky_session"
     }
   };
   ```

## æ•°æ®åŒæ­¥ç­–ç•¥

### æ–¹æ¡ˆä¸€: ä¸»åŠ¨æ•°æ®å¤åˆ¶

#### è·¨æœåŠ¡å™¨äº‹ä»¶åŒæ­¥
```rust
// src/services/distributed_sync.rs
pub struct DistributedSync {
    peer_servers: Vec<String>,
    http_client: reqwest::Client,
}

impl DistributedSync {
    pub async fn broadcast_event(&self, event: &SpinPetEvent) -> Result<()> {
        let mint_account = self.extract_mint_account(event);
        
        // å‘é€åˆ°å…¶ä»–æœåŠ¡å™¨
        for server in &self.peer_servers {
            if let Err(e) = self.send_event_to_peer(server, event).await {
                warn!("Failed to sync event to {}: {}", server, e);
            }
        }
        
        Ok(())
    }
    
    async fn send_event_to_peer(&self, server: &str, event: &SpinPetEvent) -> Result<()> {
        let url = format!("{}/api/sync/event", server);
        let response = self.http_client
            .post(&url)
            .json(event)
            .send()
            .await?;
            
        if response.status().is_success() {
            debug!("Successfully synced event to {}", server);
        }
        
        Ok(())
    }
}
```

### æ–¹æ¡ˆäºŒ: åŸºäºæ¶ˆæ¯é˜Ÿåˆ—çš„å¼‚æ­¥åŒæ­¥

#### ä½¿ç”¨ Cloudflare Queues
```javascript
// åœ¨ Cloudflare Workers ä¸­
export default {
  async queue(batch, env, ctx) {
    // å¤„ç†é˜Ÿåˆ—ä¸­çš„åŒæ­¥äº‹ä»¶
    for (const message of batch.messages) {
      const event = message.body;
      await syncEventToAllServers(event, env);
    }
  }
};
```

## è´Ÿè½½å‡è¡¡ç­–ç•¥

### 1. åŸºäº mint_account çš„åˆ†ç‰‡è´Ÿè½½å‡è¡¡

#### å®ç°åŸç†
```rust
// src/services/load_balancer.rs
pub struct MintBasedLoadBalancer {
    servers: Vec<ServerInfo>,
    hash_ring: ConsistentHashRing,
}

impl MintBasedLoadBalancer {
    pub fn get_server_for_mint(&self, mint_account: &str) -> &ServerInfo {
        self.hash_ring.get_node(mint_account)
    }
    
    pub fn add_server(&mut self, server: ServerInfo) {
        // æ·»åŠ åˆ°ä¸€è‡´æ€§å“ˆå¸Œç¯
        self.hash_ring.add_node(server.clone());
        self.servers.push(server);
    }
    
    pub fn remove_server(&mut self, server_id: &str) {
        // ä»å“ˆå¸Œç¯ç§»é™¤
        self.hash_ring.remove_node(server_id);
        self.servers.retain(|s| s.id != server_id);
    }
}
```

### 2. WebSocket è¿æ¥çš„ç²˜æ€§ä¼šè¯

#### Cloudflare Workers å®ç°
```javascript
async function handleWebSocket(request, env) {
  const url = new URL(request.url);
  const mintAccount = url.searchParams.get('mint');
  
  if (mintAccount) {
    // åŸºäº mint_account é€‰æ‹©æœåŠ¡å™¨
    const targetServer = await getServerForMint(mintAccount, env);
    return await upgradeWebSocket(request, targetServer);
  }
  
  // ä½¿ç”¨ä¼šè¯ä¿æŒ
  const sessionId = request.headers.get('CF-Connecting-IP');
  const targetServer = await getServerBySession(sessionId, env);
  return await upgradeWebSocket(request, targetServer);
}
```

## å¥åº·æ£€æŸ¥å’Œæ•…éšœè½¬ç§»

### 1. å¥åº·æ£€æŸ¥ç«¯ç‚¹
```rust
// src/handlers/health.rs
pub async fn health_check(
    State(app_state): State<AppState>,
) -> Json<HealthStatus> {
    let status = HealthStatus {
        server_id: app_state.server_id.clone(),
        status: "healthy".to_string(),
        timestamp: chrono::Utc::now(),
        
        // å…³é”®æŒ‡æ ‡
        active_connections: app_state.websocket_manager.connection_count(),
        rocksdb_status: check_rocksdb_health(&app_state.event_storage).await,
        solana_listener_status: app_state.solana_listener.is_healthy(),
        
        // mint_account ç»Ÿè®¡
        mint_count: app_state.event_storage.get_mint_count().await.unwrap_or(0),
        recent_events_count: app_state.event_storage
            .get_recent_events_count(Duration::from_secs(60)).await.unwrap_or(0),
    };
    
    Json(status)
}
```

### 2. æ•…éšœè½¬ç§»æœºåˆ¶
```javascript
// Cloudflare Workers æ•…éšœè½¬ç§»
async function handleFailover(mintAccount, failedServer, env) {
  // æ ‡è®°æœåŠ¡å™¨æ•…éšœ
  await env.FAILED_SERVERS.put(failedServer, Date.now().toString(), {
    expirationTtl: 300 // 5åˆ†é’Ÿåé‡è¯•
  });
  
  // é‡æ–°è®¡ç®—ç›®æ ‡æœåŠ¡å™¨
  const availableServers = env.SERVERS.filter(s => s !== failedServer);
  const backupServer = await getServerForMint(mintAccount, {
    ...env,
    SERVERS: availableServers
  });
  
  return backupServer;
}
```

## æœåŠ¡å™¨é…ç½®ä¿®æ”¹

### 1. æ·»åŠ æœåŠ¡å™¨æ ‡è¯†
```rust
// src/config.rs
#[derive(Debug, Deserialize)]
pub struct Config {
    pub server: ServerConfig,
    // ... å…¶ä»–é…ç½®
}

#[derive(Debug, Deserialize)]
pub struct ServerConfig {
    pub server_id: String,           // å”¯ä¸€æœåŠ¡å™¨æ ‡è¯†
    pub cluster_mode: bool,          // æ˜¯å¦å¯ç”¨é›†ç¾¤æ¨¡å¼
    pub peer_servers: Vec<String>,   // é›†ç¾¤ä¸­å…¶ä»–æœåŠ¡å™¨åœ°å€
    pub sync_enabled: bool,          // æ˜¯å¦å¯ç”¨æ•°æ®åŒæ­¥
}
```

### 2. é…ç½®æ–‡ä»¶ç¤ºä¾‹
```toml
# config/production.toml
[server]
host = "0.0.0.0"
port = 8080
server_id = "server-001"
cluster_mode = true
peer_servers = [
    "https://server-002.yourdomain.com",
    "https://server-003.yourdomain.com"
]
sync_enabled = true

[database]
path = "./data/rocksdb"

[solana]
rpc_url = "https://api.mainnet-beta.solana.com"
websocket_url = "wss://api.mainnet-beta.solana.com"
```

## éƒ¨ç½²æµç¨‹

### 1. æœåŠ¡å™¨éƒ¨ç½²
```bash
#!/bin/bash
# deploy.sh

# æ„å»º Docker é•œåƒ
docker build -t spin-server:latest .

# éƒ¨ç½²åˆ°ä¸åŒåŒºåŸŸ
regions=("us-west" "us-east" "asia-pacific" "europe")

for region in "${regions[@]}"; do
  echo "Deploying to $region..."
  
  # ç”ŸæˆåŒºåŸŸç‰¹å®šé…ç½®
  envsubst < config/template.toml > config/$region.toml
  
  # éƒ¨ç½²åˆ°äº‘æœåŠ¡å•†
  deploy_to_region "$region" "spin-server:latest"
done
```

### 2. Cloudflare Workers éƒ¨ç½²
```bash
# éƒ¨ç½²è·¯ç”± Worker
npx wrangler publish cloudflare-worker.js

# é…ç½®ç¯å¢ƒå˜é‡
wrangler secret put SERVER_COUNT
wrangler secret put SERVERS
```

## ç›‘æ§å’Œè§‚å¯Ÿæ€§

### 1. æŒ‡æ ‡æ”¶é›†
```rust
// src/metrics.rs
use prometheus::{Counter, Histogram, Registry};

lazy_static! {
    pub static ref REQUEST_COUNTER: Counter = Counter::new(
        "spin_server_requests_total", 
        "Total number of requests"
    ).unwrap();
    
    pub static ref MINT_QUERY_HISTOGRAM: Histogram = Histogram::new(
        "spin_server_mint_query_duration_seconds",
        "Time spent querying mint data"
    ).unwrap();
}

pub fn init_metrics() -> Registry {
    let registry = Registry::new();
    registry.register(Box::new(REQUEST_COUNTER.clone())).unwrap();
    registry.register(Box::new(MINT_QUERY_HISTOGRAM.clone())).unwrap();
    registry
}
```

### 2. æ—¥å¿—èšåˆ
- ä½¿ç”¨ Cloudflare Analytics Engine æ”¶é›†è¯·æ±‚æ—¥å¿—
- é…ç½® structured logging ä¾¿äºåˆ†æ
- ç›‘æ§å…³é”®æŒ‡æ ‡: å»¶è¿Ÿã€é”™è¯¯ç‡ã€mint_account åˆ†å¸ƒ

## æˆæœ¬ä¼˜åŒ–å»ºè®®

### 1. èµ„æºå±‚æ¬¡åŒ–
- **çƒ­æ•°æ®æœåŠ¡å™¨**: é«˜æ€§èƒ½ SSDï¼Œå¤„ç†æœ€è¿‘ 7 å¤©æ•°æ®
- **æ¸©æ•°æ®æœåŠ¡å™¨**: æ™®é€š SSDï¼Œå¤„ç† 7-30 å¤©æ•°æ®  
- **å†·æ•°æ®æœåŠ¡å™¨**: ä¾¿å®œå­˜å‚¨ï¼Œå¤„ç†å†å²æ•°æ®

### 2. æŒ‰éœ€æ‰©å®¹
```javascript
// Cloudflare Workers è‡ªåŠ¨æ‰©å®¹
async function autoScale(env) {
  const metrics = await fetchClusterMetrics(env);
  
  if (metrics.avgCpuUsage > 80 && metrics.activeConnections > 1000) {
    // è§¦å‘æ‰©å®¹
    await scaleUp(env);
  } else if (metrics.avgCpuUsage < 20 && metrics.activeConnections < 100) {
    // è§¦å‘ç¼©å®¹
    await scaleDown(env);
  }
}
```

## æ•°æ®ç¼ºå¤±å¤„ç†ç­–ç•¥

### å†·å¯åŠ¨é—®é¢˜è§£å†³

#### 1. å†å²æ•°æ®åŒæ­¥æœºåˆ¶

```rust
// src/services/data_sync.rs
pub struct DataSyncService {
    local_storage: Arc<EventStorage>,
    peer_clients: HashMap<String, reqwest::Client>,
    sync_config: SyncConfig,
}

#[derive(Debug, Clone)]
pub struct SyncConfig {
    pub batch_size: usize,           // æ¯æ¬¡åŒæ­¥çš„äº‹ä»¶æ•°é‡
    pub max_parallel_syncs: usize,   // æœ€å¤§å¹¶è¡ŒåŒæ­¥ä»»åŠ¡æ•°
    pub sync_interval: Duration,     // åŒæ­¥é—´éš”
    pub backfill_enabled: bool,      // æ˜¯å¦å¯ç”¨å›å¡«å†å²æ•°æ®
}

impl DataSyncService {
    /// å¯åŠ¨æ—¶æ£€æŸ¥å¹¶å›å¡«ç¼ºå¤±æ•°æ®
    pub async fn startup_sync(&self) -> Result<()> {
        info!("ğŸ”„ Starting data synchronization...");
        
        // 1. è·å–å…¶ä»–æœåŠ¡å™¨çš„ mint_account åˆ—è¡¨
        let peer_mints = self.get_all_peer_mints().await?;
        
        // 2. å¯¹æ¯”æœ¬åœ°ç¼ºå¤±çš„ mint_account
        let local_mints = self.local_storage.get_all_mints().await?;
        let missing_mints: Vec<String> = peer_mints.into_iter()
            .filter(|mint| !local_mints.contains(mint))
            .collect();
            
        info!("ğŸ“¥ Found {} missing mints to sync", missing_mints.len());
        
        // 3. åˆ†æ‰¹åŒæ­¥ç¼ºå¤±æ•°æ®
        for chunk in missing_mints.chunks(self.sync_config.batch_size) {
            let sync_futures: Vec<_> = chunk.iter()
                .map(|mint| self.sync_mint_data(mint))
                .collect();
                
            futures::future::join_all(sync_futures).await;
            
            // é¿å…è¿‡è½½
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
        
        info!("âœ… Data synchronization completed");
        Ok(())
    }
    
    /// åŒæ­¥ç‰¹å®š mint_account çš„æ•°æ®
    async fn sync_mint_data(&self, mint_account: &str) -> Result<()> {
        // 1. æ‰¾åˆ°æœ‰è¿™ä¸ª mint æ•°æ®çš„æœåŠ¡å™¨
        let source_servers = self.find_data_sources(mint_account).await?;
        
        if source_servers.is_empty() {
            warn!("âš ï¸ No data source found for mint: {}", mint_account);
            return Ok(());
        }
        
        // 2. é€‰æ‹©æœ€å®Œæ•´çš„æ•°æ®æº
        let best_source = source_servers.iter()
            .max_by_key(|s| s.event_count)
            .unwrap();
            
        info!("ğŸ“¡ Syncing mint {} from server {}", 
            mint_account, best_source.server_id);
            
        // 3. åˆ†é¡µè·å–æ‰€æœ‰æ•°æ®
        let mut page = 1;
        let page_size = 1000;
        
        loop {
            let events = self.fetch_events_from_peer(
                &best_source.endpoint, 
                mint_account, 
                page, 
                page_size
            ).await?;
            
            if events.is_empty() {
                break;
            }
            
            // 4. æ‰¹é‡æ’å…¥æœ¬åœ°å­˜å‚¨
            for event in &events {
                if let Err(e) = self.local_storage.store_event(event).await {
                    warn!("Failed to store synced event: {}", e);
                }
            }
            
            info!("ğŸ“¥ Synced page {} ({} events) for mint {}", 
                page, events.len(), mint_account);
                
            page += 1;
            
            if events.len() < page_size {
                break; // Last page
            }
        }
        
        Ok(())
    }
    
    async fn get_all_peer_mints(&self) -> Result<Vec<String>> {
        let mut all_mints = HashSet::new();
        
        let futures: Vec<_> = self.peer_clients.iter()
            .map(|(server_id, client)| {
                self.fetch_mint_list(server_id, client)
            })
            .collect();
            
        let results = futures::future::join_all(futures).await;
        
        for result in results {
            if let Ok(mints) = result {
                all_mints.extend(mints);
            }
        }
        
        Ok(all_mints.into_iter().collect())
    }
}
```

#### 2. æ™ºèƒ½æ•°æ®è·¯ç”±

```javascript
// åœ¨ Cloudflare Workers ä¸­å¤„ç†æ•°æ®ç¼ºå¤±
async function handleMissingData(mintAccount, request, env) {
  console.log(`ğŸ” Searching for mint data: ${mintAccount}`);
  
  // 1. å¹¿æ’­åˆ°æ‰€æœ‰å¥åº·æœåŠ¡å™¨
  const searchPromises = env.SERVERS.map(async server => {
    if (await isServerHealthy(server, env)) {
      return await searchMintOnServer(server, mintAccount, request);
    }
    return null;
  });
  
  const searchResults = await Promise.allSettled(searchPromises);
  
  // 2. æ”¶é›†æ‰€æœ‰æ‰¾åˆ°æ•°æ®çš„æœåŠ¡å™¨
  const foundServers = [];
  for (const result of searchResults) {
    if (result.status === 'fulfilled' && result.value) {
      foundServers.push(result.value);
    }
  }
  
  if (foundServers.length === 0) {
    return new Response(JSON.stringify({
      error: 'mint_not_found',
      mint_account: mintAccount,
      message: 'This mint account was not found on any server',
      suggestion: 'The mint may not exist or servers are still syncing'
    }), { status: 404 });
  }
  
  // 3. é€‰æ‹©æœ€ä½³æ•°æ®æºå¹¶æ›´æ–°æ³¨å†Œè¡¨
  const bestServer = selectBestDataSource(foundServers);
  await updateMintRegistry(mintAccount, bestServer, env);
  
  // 4. è½¬å‘åˆ°æœ€ä½³æœåŠ¡å™¨
  return await forwardToServer(request, bestServer);
}

async function searchMintOnServer(server, mintAccount, request) {
  try {
    const searchUrl = new URL(request.url);
    searchUrl.hostname = server.hostname;
    searchUrl.port = server.port || '';
    
    // æ·»åŠ æ£€æŸ¥å‚æ•°ï¼ŒåªæŸ¥è¯¢æ˜¯å¦å­˜åœ¨ï¼Œä¸è¿”å›å¤§é‡æ•°æ®
    searchUrl.searchParams.set('check_only', 'true');
    searchUrl.searchParams.set('limit', '1');
    
    const response = await fetch(searchUrl.toString(), {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'User-Agent': 'Cloudflare-Worker-Router/1.0'
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      if (data.total > 0) {
        return {
          server: server,
          event_count: data.total,
          last_updated: Date.now()
        };
      }
    }
    
    return null;
  } catch (error) {
    console.error(`Error searching mint on ${server.hostname}: ${error}`);
    return null;
  }
}

function selectBestDataSource(foundServers) {
  // é€‰æ‹©æ•°æ®æœ€å¤šçš„æœåŠ¡å™¨
  return foundServers.reduce((best, current) => {
    return current.event_count > best.event_count ? current : best;
  });
}
```

#### 3. æ¸è¿›å¼æ•°æ®å‘ç°

```rust
// src/services/progressive_discovery.rs
pub struct ProgressiveDiscoveryService {
    local_storage: Arc<EventStorage>,
    registry_client: Arc<RegistryClient>,
    discovery_cache: Arc<RwLock<HashMap<String, DiscoveryResult>>>,
}

#[derive(Debug, Clone)]
struct DiscoveryResult {
    servers_checked: Vec<String>,
    data_found: bool,
    best_server: Option<String>,
    last_check: i64,
    check_count: usize,
}

impl ProgressiveDiscoveryService {
    /// æ¸è¿›å¼æŸ¥æ‰¾ mint_account æ•°æ®
    pub async fn discover_mint(&self, mint_account: &str) -> Result<Option<String>> {
        // 1. æ£€æŸ¥ç¼“å­˜
        if let Some(cached) = self.get_cached_result(mint_account).await {
            if !self.should_refresh_cache(&cached) {
                return Ok(cached.best_server.clone());
            }
        }
        
        // 2. å¿«é€Ÿæœ¬åœ°æ£€æŸ¥
        if self.local_storage.has_mint_data(mint_account).await? {
            return Ok(Some("local".to_string()));
        }
        
        // 3. æŸ¥è¯¢æ³¨å†Œè¡¨
        if let Some(servers) = self.registry_client
            .find_servers_for_mint(mint_account).await {
            if !servers.is_empty() {
                let best_server = servers[0].endpoint.clone();
                self.cache_discovery_result(mint_account, servers).await;
                return Ok(Some(best_server));
            }
        }
        
        // 4. å¹¿æ’­æœç´¢ï¼ˆæœ€åæ‰‹æ®µï¼‰
        self.broadcast_search(mint_account).await
    }
    
    async fn broadcast_search(&self, mint_account: &str) -> Result<Option<String>> {
        info!("ğŸ” Broadcasting search for mint: {}", mint_account);
        
        // å®ç°æ™ºèƒ½æœç´¢ç­–ç•¥ï¼š
        // - ä¼˜å…ˆæœç´¢æœ€è¿‘æ´»è·ƒçš„æœåŠ¡å™¨
        // - æŒ‰åœ°ç†ä½ç½®å°±è¿‘æœç´¢
        // - é¿å…é‡å¤æœç´¢å·²ç¡®è®¤æ²¡æœ‰æ•°æ®çš„æœåŠ¡å™¨
        
        let mut discovery_result = DiscoveryResult {
            servers_checked: Vec::new(),
            data_found: false,
            best_server: None,
            last_check: chrono::Utc::now().timestamp(),
            check_count: 1,
        };
        
        // åˆ†æ‰¹æœç´¢ï¼Œé¿å…é›ªå´©
        let peer_servers = self.get_prioritized_peer_list().await?;
        
        for batch in peer_servers.chunks(3) {  // æ¯æ‰¹3ä¸ªæœåŠ¡å™¨
            let search_futures: Vec<_> = batch.iter()
                .map(|server| self.search_server_for_mint(server, mint_account))
                .collect();
                
            let results = futures::future::join_all(search_futures).await;
            
            for (i, result) in results.into_iter().enumerate() {
                let server = &batch[i];
                discovery_result.servers_checked.push(server.clone());
                
                if let Ok(Some(server_endpoint)) = result {
                    discovery_result.data_found = true;
                    discovery_result.best_server = Some(server_endpoint.clone());
                    
                    // ç«‹å³æ›´æ–°æ³¨å†Œè¡¨
                    let _ = self.registry_client.register_mint_discovery(
                        mint_account, &server_endpoint
                    ).await;
                    
                    break;
                }
            }
            
            if discovery_result.data_found {
                break;
            }
            
            // æ‰¹æ¬¡é—´å»¶è¿Ÿ
            tokio::time::sleep(Duration::from_millis(200)).await;
        }
        
        // ç¼“å­˜æœç´¢ç»“æœï¼ˆåŒ…æ‹¬æœªæ‰¾åˆ°çš„ç»“æœï¼‰
        self.cache_discovery_result(mint_account, vec![]).await;
        
        Ok(discovery_result.best_server)
    }
    
    /// æ™ºèƒ½ç¼“å­˜ç­–ç•¥
    fn should_refresh_cache(&self, result: &DiscoveryResult) -> bool {
        let now = chrono::Utc::now().timestamp();
        let age = now - result.last_check;
        
        // æ ¹æ®æŸ¥æ‰¾ç»“æœè°ƒæ•´ç¼“å­˜æ—¶é—´
        let max_age = if result.data_found {
            3600  // æ‰¾åˆ°æ•°æ®ï¼šç¼“å­˜1å°æ—¶
        } else {
            300   // æœªæ‰¾åˆ°ï¼šç¼“å­˜5åˆ†é’Ÿï¼ˆå¯èƒ½æ˜¯æ–°mintï¼‰
        };
        
        age > max_age || (result.check_count < 3 && age > 60)
    }
}
```

### æ•°æ®ä¸€è‡´æ€§ä¿éšœ

#### 1. æœ€ç»ˆä¸€è‡´æ€§ç­–ç•¥
- **å†™å…¥ç¡®è®¤**: äº‹ä»¶å†™å…¥åå¼‚æ­¥åŒæ­¥åˆ°å…¶ä»–èŠ‚ç‚¹
- **è¯»å–ä¿®å¤**: è¯»å–æ—¶æ£€æµ‹æ•°æ®ä¸ä¸€è‡´å¹¶ä¿®å¤
- **å®šæœŸæ ¡éªŒ**: åå°ä»»åŠ¡å®šæœŸæ ¡éªŒæ•°æ®å®Œæ•´æ€§

#### 2. å†²çªè§£å†³æœºåˆ¶
- **æ—¶é—´æˆ³ä¼˜å…ˆ**: ä½¿ç”¨åŒºå—é“¾æ§½ä½å·ä½œä¸ºæƒå¨æ—¶é—´æˆ³
- **æ•°æ®åˆå¹¶**: åŒä¸€äº‹ä»¶çš„é‡å¤æ•°æ®è‡ªåŠ¨å»é‡
- **ç‰ˆæœ¬å‘é‡**: è·Ÿè¸ªæ¯ä¸ªæœåŠ¡å™¨çš„æ•°æ®ç‰ˆæœ¬

## æ€»ç»“

é€šè¿‡ä»¥ä¸Šåˆ†å¸ƒå¼æ¶æ„è®¾è®¡ï¼Œå¯ä»¥å®ç°:

1. **é«˜å¯ç”¨æ€§**: å¤šåŒºåŸŸéƒ¨ç½²ï¼Œè‡ªåŠ¨æ•…éšœè½¬ç§»
2. **å¯æ‰©å±•æ€§**: åŸºäº mint_account çš„æ°´å¹³åˆ†ç‰‡  
3. **åŠ¨æ€å‘ç°**: æ™ºèƒ½è·¯ç”±å’Œæ•°æ®å‘ç°æœºåˆ¶
4. **æ•°æ®ä¸€è‡´**: æ¸è¿›å¼åŒæ­¥å’Œå†²çªè§£å†³
5. **æ€§èƒ½ä¼˜åŒ–**: Cloudflare è¾¹ç¼˜è®¡ç®—åŠ é€Ÿ
6. **æˆæœ¬æ§åˆ¶**: æŒ‰éœ€æ‰©å®¹ï¼Œèµ„æºå±‚æ¬¡åŒ–

### å®æ–½è·¯çº¿å›¾

**ç¬¬ä¸€é˜¶æ®µ: åŸºç¡€æ¶æ„** (2-3å‘¨)
1. å®ç° Cloudflare Workers æ™ºèƒ½è·¯ç”±
2. æ·»åŠ æœåŠ¡å™¨æ³¨å†Œå’Œå‘ç°æœºåˆ¶
3. å»ºç«‹å¥åº·æ£€æŸ¥å’Œæ•…éšœè½¬ç§»

**ç¬¬äºŒé˜¶æ®µ: æ•°æ®ç®¡ç†** (3-4å‘¨)
1. å®ç°åˆ†å¸ƒå¼æ•°æ®ç´¢å¼•
2. æ·»åŠ æ¸è¿›å¼æ•°æ®å‘ç°
3. å»ºç«‹æ•°æ®åŒæ­¥æœºåˆ¶

**ç¬¬ä¸‰é˜¶æ®µ: ä¼˜åŒ–å¢å¼º** (2-3å‘¨)
1. æ€§èƒ½ä¼˜åŒ–å’Œç¼“å­˜ç­–ç•¥
2. ç›‘æ§å‘Šè­¦å’Œè‡ªåŠ¨åŒ–è¿ç»´
3. æˆæœ¬ä¼˜åŒ–å’Œèµ„æºç®¡ç†

**ç¬¬å››é˜¶æ®µ: ç”Ÿäº§éƒ¨ç½²** (1-2å‘¨)
1. ç°åº¦å‘å¸ƒå’ŒA/Bæµ‹è¯•
2. ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–
3. æ–‡æ¡£å’ŒåŸ¹è®­
